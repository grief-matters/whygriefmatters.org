---
import Button from "@ui/primitives/Button.astro";
import ContentSurface from "@ui/primitives/ContentSurface.astro";
import Icon from "@ui/primitives/Icon.astro";
import Typography from "@ui/primitives/Typography.astro";
---

<search-controller>
  <!-- Trigger button (styled like the original placeholder) -->
  <button
    type="button"
    data-search-trigger
    class:list={[
      "grow basis-40 px-3 py-1 border rounded-full border-line-primary--muted sm:max-w-60",
      "cursor-pointer hover:border-line-primary--default transition-colors",
      "flex items-center gap-1",
    ]}
  >
    <Icon
      getIcon={(icons) => icons.magnifyingGlass}
      color="primary"
      display="inline"
    />
    <span
      class:list={["align-middle font-serif text-onSurface-coolNeutral--muted"]}
    >
      {"Search..."}
    </span>
  </button>

  <!-- Modal overlay -->
  <div data-search-modal hidden>
    <!-- Backdrop (sibling, clickable to close) -->
    <div data-search-backdrop class:list={["fixed inset-0 bg-black/50"]}></div>
    <!-- Content -->
    <div
      data-search-content
      class:list={["fixed inset-0 sm:inset-24 lg:max-w-6xl lg:mx-auto z-50"]}
    >
      <ContentSurface
        variant="featureCard"
        fullHeight
        paddingX={3}
        paddingY={3}
      >
        <div class="flex flex-col h-full gap-1.5">
          <div class="flex justify-end items-center gap-3 shrink-0">
            <Button data-search-close colorVariant="primary">
              <Typography
                variant="button-2"
                as="span"
                color="primary"
                set:text="Close"
              />
              <span class="text-onSurface-primary--muted text-sm">[esc]</span>
            </Button>
          </div>

          <!-- Search input -->
          <div class="overflow-x-hidden max-w-full shrink-0">
            <Icon
              getIcon={(icons) => icons.magnifyingGlass}
              color="coolNeutral"
              display="inline"
            />
            <input
              name="search-input"
              type="text"
              data-search-input
              placeholder="Search resources..."
              autocomplete="off"
              class:list={[
                "field-sizing-content",
                "ml-1 min-w-0 truncate",
                "font-serif text-onSurface-coolNeutral--default",
                "border-b border-line-coolNeutral--muted",
                "focus:border-line-primary--default focus:outline-none",
                "transition-colors",
              ]}
            />
          </div>

          <!-- Results container -->
          <div
            data-search-results
            class:list={["mt-2 overflow-y-auto flex-1 min-h-0", "empty:hidden"]}
          >
            <!-- Results rendered here by JavaScript -->
          </div>

          <!-- Loading indicator -->
          <div
            data-search-loading
            hidden
            class="py-4 text-center text-onSurface-coolNeutral--muted font-serif shrink-0"
          >
            <Typography>{"Searching..."}</Typography>
          </div>

          <!-- No results message -->
          <div
            data-search-empty
            hidden
            class="py-4 text-center text-onSurface-coolNeutral--muted font-serif shrink-0"
          >
            <Typography>{"No results found"}</Typography>
          </div>
        </div>
      </ContentSurface>
    </div>
  </div>
</search-controller>

<script>
  import debounce from "lodash/debounce";
  import type { Pagefind, PagefindSearchResult } from "../../types/pagefind";

  class SearchController extends HTMLElement {
    private pagefind: Pagefind | null = null;
    private selectedIndex: number = -1;
    private results: Array<{ url: string; title: string; excerpt: string }> =
      [];
    private debouncedHandleSearch = debounce((query: string) => {
      this.handleSearch(query);
    }, 300);

    connectedCallback() {
      const trigger = this.querySelector("[data-search-trigger]");
      const input = this.querySelector(
        "[data-search-input]",
      ) as HTMLInputElement;

      // Open modal on trigger click
      trigger?.addEventListener("click", () => this.openModal());

      // Close modal on close button click
      const closeButton = this.querySelector("[data-search-close]");
      closeButton?.addEventListener("click", () => this.closeModal());

      // Close modal on backdrop click
      const backdrop = this.querySelector("[data-search-backdrop]");
      backdrop?.addEventListener("click", () => this.closeModal());

      // Handle input
      input?.addEventListener("input", (e) => {
        const query = (e.target as HTMLInputElement).value;
        this.debouncedHandleSearch(query);
      });

      // Handle keyboard navigation
      input?.addEventListener("keydown", (e) => this.handleKeydown(e));

      // Global escape key
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          this.closeModal();
        }
      });
    }

    openModal() {
      const modal = this.querySelector("[data-search-modal]");
      const input = this.querySelector(
        "[data-search-input]",
      ) as HTMLInputElement;

      modal?.removeAttribute("hidden");
      input?.focus();

      // Initialize Pagefind lazily
      if (!this.pagefind) {
        this.initPagefind();
      }
    }

    closeModal() {
      const modal = this.querySelector("[data-search-modal]");
      const input = this.querySelector(
        "[data-search-input]",
      ) as HTMLInputElement;
      const resultsContainer = this.querySelector("[data-search-results]");

      this.debouncedHandleSearch.cancel();
      modal?.setAttribute("hidden", "");
      if (input) input.value = "";
      if (resultsContainer) resultsContainer.innerHTML = "";
      this.results = [];
      this.selectedIndex = -1;
      this.hideLoading();
      this.hideEmpty();
    }

    async initPagefind() {
      try {
        // Pagefind is generated at build time, use dynamic import with variable to bypass TS
        const pagefindPath = "/pagefind/pagefind.js";
        const pagefind: Pagefind = await import(
          /* @vite-ignore */ pagefindPath
        );
        await pagefind.init();
        this.pagefind = pagefind;
      } catch (err) {
        console.error("Failed to load Pagefind:", err);
      }
    }

    async handleSearch(query: string) {
      if (!query.trim()) {
        this.clearResults();
        return;
      }

      if (!this.pagefind) {
        await this.initPagefind();
      }

      if (!this.pagefind) {
        return;
      }

      this.showLoading();

      try {
        const search = await this.pagefind.debouncedSearch(query);
        if (!search || !search.results) {
          this.hideLoading();
          this.showEmpty();
          return;
        }

        // Load top 10 results
        const resultsData = await Promise.all(
          search.results
            .slice(0, 10)
            .map((r: PagefindSearchResult) => r.data()),
        );

        // Extract sub_results for individual resources
        this.results = [];
        for (const result of resultsData) {
          const subResults = result.sub_results || [];
          for (const sub of subResults) {
            this.results.push({
              url: sub.url,
              title: sub.title || result.meta?.title || "Untitled",
              excerpt: sub.excerpt || "",
            });
          }
          // If no sub_results, use the main result
          if (subResults.length === 0) {
            this.results.push({
              url: result.url,
              title: result.meta?.title || "Untitled",
              excerpt: result.excerpt || "",
            });
          }
        }

        this.hideLoading();

        if (this.results.length === 0) {
          this.showEmpty();
        } else {
          this.hideEmpty();
          this.renderResults();
        }
      } catch (err) {
        console.error("Search error:", err);
        this.hideLoading();
      }
    }

    renderResults() {
      const container = this.querySelector("[data-search-results]");
      if (!container) return;

      container.innerHTML = this.results
        .map(
          (result, index) => `
          <a
            href="${result.url}"
            data-result-index="${index}"
            class="not-last:border-b border-b-line-coolNeutral--default block p-3 rounded hover:bg-contentSurface-neutral--muted transition-colors ${
              index === this.selectedIndex
                ? "bg-contentSurface-neutral--muted"
                : ""
            }"
          >
            <p class="font-serif text-onSurface-primary--default font-bold mb-2">
              ${this.escapeHtml(result.title)}
            </p>
            <p class="text-sm font-serif text-onSurface-primary--default line-clamp-2">
              <span class="after:content-[...]">${result.excerpt}</span>
            </p>
          </a>
        `,
        )
        .join("");

      // Add click handlers
      container.querySelectorAll("a").forEach((link) => {
        link.addEventListener("click", () => this.closeModal());
      });
    }

    clearResults() {
      const container = this.querySelector("[data-search-results]");
      if (container) container.innerHTML = "";
      this.results = [];
      this.selectedIndex = -1;
      this.hideEmpty();
    }

    handleKeydown(e: KeyboardEvent) {
      if (this.results.length === 0) return;

      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          this.selectedIndex = (this.selectedIndex + 1) % this.results.length;
          this.updateSelection();
          break;
        case "ArrowUp":
          e.preventDefault();
          this.selectedIndex =
            this.selectedIndex <= 0
              ? this.results.length - 1
              : this.selectedIndex - 1;
          this.updateSelection();
          break;
        case "Enter":
          e.preventDefault();
          if (this.selectedIndex >= 0 && this.results[this.selectedIndex]) {
            window.location.href = this.results[this.selectedIndex].url;
            this.closeModal();
          }
          break;
      }
    }

    updateSelection() {
      const container = this.querySelector("[data-search-results]");
      if (!container) return;

      container.querySelectorAll("a").forEach((link, index) => {
        if (index === this.selectedIndex) {
          link.classList.add("bg-contentSurface-neutral--muted");
          link.scrollIntoView({ block: "nearest" });
        } else {
          link.classList.remove("bg-contentSurface-neutral--muted");
        }
      });
    }

    showLoading() {
      this.querySelector("[data-search-loading]")?.removeAttribute("hidden");
      this.querySelector("[data-search-results]")?.setAttribute("hidden", "");
    }

    hideLoading() {
      this.querySelector("[data-search-loading]")?.setAttribute("hidden", "");
      this.querySelector("[data-search-results]")?.removeAttribute("hidden");
    }

    showEmpty() {
      this.querySelector("[data-search-empty]")?.removeAttribute("hidden");
    }

    hideEmpty() {
      this.querySelector("[data-search-empty]")?.setAttribute("hidden", "");
    }

    escapeHtml(text: string): string {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }
  }

  customElements.define("search-controller", SearchController);
</script>
