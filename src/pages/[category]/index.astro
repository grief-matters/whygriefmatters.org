---
import {
  getCollection,
  getEntries,
  type CollectionEntry,
  type ReferenceDataEntry,
} from "astro:content";

import {
  internetResourceCollectionKeys,
  type InternetResourceCollectionKey,
  type InternetResourceEntries,
} from "@content/collections";

import Slide from "@ui/layouts/slider/Slide.astro";
import Slider from "@ui/layouts/slider/Slider.astro";

import CategoryPopulationsNavigator from "@ui/composites/CategoryPopulationsNavigator.astro";

import Container from "@ui/primitives/Container.astro";
import LayoutSurface from "@ui/primitives/LayoutSurface.astro";
import PortableTextContentBlock from "@ui/primitives/PortableTextContentBlock.astro";
import Typography from "@ui/primitives/Typography.astro";

import CategoryPageHeader from "@ui/composites/CategoryPageHeader.astro";
import FeaturedResourceRenderer from "@ui/orchestrators/FeaturedResourceRenderer.astro";
import ResourceListingsOrchestrator from "@ui/orchestrators/ResourceListingsOrchestrator.astro";
import SitePageLayout from "@ui/layouts/SitePageLayout.astro";

interface Props {
  categoryEntry: CollectionEntry<"categories">;
  internetResources: InternetResourceEntries;
  populations: Array<CollectionEntry<"populations">>;
  resourceTypes: Array<InternetResourceCollectionKey>;
  parentCategory?: CollectionEntry<"categories">;
}

// Helper function to recursively get all descendant category IDs
export function getAllDescendantCategoryIds(
  categoryId: string,
  allCategories: Array<CollectionEntry<"categories">>,
): Set<string> {
  const categoryIds = new Set<string>([categoryId]);

  const category = allCategories.find((c) => c.id === categoryId);
  if (!category || category.data.subcategories.length === 0) {
    return categoryIds;
  }

  for (const subcategoryRef of category.data.subcategories) {
    const descendantIds = getAllDescendantCategoryIds(
      subcategoryRef.id,
      allCategories,
    );
    descendantIds.forEach((id) => categoryIds.add(id));
  }

  return categoryIds;
}

export async function getResourcesFor<K extends InternetResourceCollectionKey>(
  key: K,
  categoryId: string,
): Promise<Array<CollectionEntry<K>>> {
  const result = await getCollection(key, ({ data }) =>
    data.categories.some((c) => c.id === categoryId),
  );

  return result;
}

export async function getStaticPaths() {
  const categoryEntries = await getCollection("categories");
  const staticPaths = [];

  for (const categoryEntry of categoryEntries) {
    const parentCategory = categoryEntries.find((entry) =>
      entry.data.subcategories.map((c) => c.id).includes(categoryEntry.id),
    );

    // Get all category IDs including current and all descendants
    const allCategoryIds = getAllDescendantCategoryIds(
      categoryEntry.id,
      categoryEntries,
    );

    const internetResources: InternetResourceEntries = {};
    const populationMap: Record<
      string,
      ReferenceDataEntry<"populations", string>
    > = {};

    for (const key of internetResourceCollectionKeys) {
      // const resourcesForKey = await getResourcesFor(key, categoryEntry.id);
      const resourcesForKey = await getCollection(key, ({ data }) =>
        data.categories.some((c) => allCategoryIds.has(c.id)),
      );

      resourcesForKey.forEach((r) =>
        r.data.populations.forEach((p) => (populationMap[p.id] = p)),
      );

      if (resourcesForKey.length > 0) {
        // TS can't be sure that 'key' is one of the literals its expecting - but we know better (we think)
        // we *could* use a Record type for `internetResources` but we'll lose the nice type inference we get
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (internetResources as any)[key] = resourcesForKey;
      }
    }

    const populations = await getEntries(Object.values(populationMap));

    const resourceTypes = Object.keys(internetResources);

    staticPaths.push({
      params: {
        category: categoryEntry.data.slug,
      },
      props: {
        categoryEntry,
        internetResources,
        resourceTypes,
        populations,
        parentCategory,
      },
    });
  }

  return staticPaths;
}

const props = Astro.props;
---

<SitePageLayout>
  <CategoryPageHeader
    categoryEntryData={props.categoryEntry.data}
    parentCategory={props.parentCategory}
  />

  {/* Category Description */}
  {
    props.categoryEntry.data.description && (
      <LayoutSurface paddingY={6}>
        <Container paddingX={4}>
          {props.categoryEntry.data.description && (
            <PortableTextContentBlock
              textVariant="prominent-first"
              textAlign="center"
              portableText={props.categoryEntry.data.description}
            />
          )}
        </Container>
      </LayoutSurface>
    )
  }

  {/* Underserved Populations */}
  {
    props.populations.length > 0 && (
      <LayoutSurface paddingX={2} paddingY={4}>
        <Container>
          <CategoryPopulationsNavigator
            category={props.categoryEntry}
            populations={props.populations}
          />
        </Container>
      </LayoutSurface>
    )
  }

  {/* Featured Resources */}
  {
    (props.categoryEntry.data.featuredResources ?? []).length > 0 && (
      <LayoutSurface paddingY={6} variantKey={4}>
        <Container>
          <Typography
            textAlign="center"
            marginBottom={2}
            as="h2"
            variant="title-2"
            set:text="Featured Resources"
          />
        </Container>
        <Slider>
          {props.categoryEntry.data.featuredResources.map((resource) => (
            <Slide paddingX={1} paddingY={4}>
              <FeaturedResourceRenderer
                fullHeight
                resourceRef={resource.refId}
                resourceType={resource.refType}
              />
            </Slide>
          ))}
        </Slider>
      </LayoutSurface>
    )
  }

  <LayoutSurface as="section" paddingX={2} paddingY={5}>
    <ResourceListingsOrchestrator
      internetResources={props.internetResources}
      resourceTypes={props.resourceTypes}
    />
  </LayoutSurface>
</SitePageLayout>
