---
import {
  getCollection,
  getEntries,
  type CollectionEntry,
  type ReferenceDataEntry,
} from "astro:content";

import Shell from "@ui/layouts/Shell.astro";
import {
  internetResourceCollectionKeys,
  type InternetResourceCollectionKey,
  type InternetResourceEntries,
} from "@content/collections";
import InternetResourceListingRenderer from "@ui/orchestrators/InternetResourceListingRenderer.astro";
import startCase from "lodash/startCase";
import PortableTextContentBlock from "@ui/primitives/PortableTextContentBlock.astro";
import CategoryPopulationsNavigator from "@ui/composites/CategoryPopulationsNavigator.astro";

interface Props {
  categoryEntry: CollectionEntry<"categories">;
  internetResources: InternetResourceEntries;
  populations: Array<CollectionEntry<"populations">>;
  parentCategory?: CollectionEntry<"categories">;
}

// Helper function to recursively get all descendant category IDs
export function getAllDescendantCategoryIds(
  categoryId: string,
  allCategories: Array<CollectionEntry<"categories">>
): Set<string> {
  const categoryIds = new Set<string>([categoryId]);

  const category = allCategories.find((c) => c.id === categoryId);
  if (!category || category.data.subcategories.length === 0) {
    return categoryIds;
  }

  for (const subcategoryRef of category.data.subcategories) {
    const descendantIds = getAllDescendantCategoryIds(
      subcategoryRef.id,
      allCategories
    );
    descendantIds.forEach((id) => categoryIds.add(id));
  }

  return categoryIds;
}

export async function getResourcesFor<K extends InternetResourceCollectionKey>(
  key: K,
  categoryId: string
): Promise<Array<CollectionEntry<K>>> {
  const result = await getCollection(key, ({ data }) =>
    data.categories.some((c) => c.id === categoryId)
  );

  return result;
}

export async function getStaticPaths() {
  const categoryEntries = await getCollection("categories");
  const staticPaths = [];

  for (const categoryEntry of categoryEntries) {
    const parentCategory = categoryEntries.find((entry) =>
      entry.data.subcategories.map((c) => c.id).includes(categoryEntry.id)
    );

    // Get all category IDs including current and all descendants
    const allCategoryIds = getAllDescendantCategoryIds(
      categoryEntry.id,
      categoryEntries
    );

    const internetResources: InternetResourceEntries = {};
    const populationMap: Record<
      string,
      ReferenceDataEntry<"populations", string>
    > = {};

    for (const key of internetResourceCollectionKeys) {
      // const resourcesForKey = await getResourcesFor(key, categoryEntry.id);
      const resourcesForKey = await getCollection(key, ({ data }) =>
        data.categories.some((c) => allCategoryIds.has(c.id))
      );

      resourcesForKey.forEach((r) =>
        r.data.populations.forEach((p) => (populationMap[p.id] = p))
      );

      if (resourcesForKey.length > 0) {
        // TS can't be sure that 'key' is one of the literals its expecting - but we know better (we think)
        // we *could* use a Record type for `internetResources` but we'll lose the nice type inference we get
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (internetResources as any)[key] = resourcesForKey;
      }
    }

    const populations = await getEntries(Object.values(populationMap));

    staticPaths.push({
      params: {
        category: categoryEntry.data.slug,
      },
      props: {
        categoryEntry,
        internetResources,
        populations,
        parentCategory,
      },
    });
  }

  return staticPaths;
}

const props = Astro.props;

let resolvedSubcategories: Array<CollectionEntry<"categories">> | null = null;
if (props.categoryEntry.data.subcategories.length > 0) {
  const c = await getEntries(props.categoryEntry.data.subcategories);
  resolvedSubcategories = c;
}
---

<Shell>
  <!-- Page Header Content -->
  <header>
    <h1>
      {props.categoryEntry.data.displayTitle ?? props.categoryEntry.data.title}
    </h1>
    {
      props.categoryEntry.data.shortDescription && (
        <p>{props.categoryEntry.data.shortDescription}</p>
      )
    }
    {
      resolvedSubcategories !== null && resolvedSubcategories?.length > 0 && (
        <nav>
          <p>{"Explore further:"}</p>
          <ul>
            {resolvedSubcategories.map((c) => (
              <li>
                <a href={`/${c.data.slug}`}>{c.data.title}</a>
              </li>
            ))}
          </ul>
          {props.parentCategory && (
            <p>
              {"Part of "}
              <a href={`/${props.parentCategory.data.slug}`}>
                {props.parentCategory.data.displayTitle ??
                  props.parentCategory.data.title}
              </a>
            </p>
          )}
        </nav>
      )
    }
  </header>
  <div>
    {
      props.categoryEntry.data.description && (
        <PortableTextContentBlock
          portableText={props.categoryEntry.data.description}
        />
      )
    }
    {
      props.populations.length > 0 && (
        <CategoryPopulationsNavigator
          category={props.categoryEntry}
          populations={props.populations}
        />
      )
    }
  </div>
  <section>
    {/* TODO - featured resources */}
  </section>
  <section>
    {
      Object.entries(props.internetResources).map(
        ([resourceType, resourceEntries]) => (
          <div>
            <h2>{startCase(resourceType)}</h2>
            {resourceEntries.map((entry) => (
              <InternetResourceListingRenderer entry={entry} />
            ))}
          </div>
        )
      )
    }
  </section>
</Shell>
