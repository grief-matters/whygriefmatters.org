---
import SitePageLayout from "@ui/layouts/SitePageLayout.astro";
import Typography from "@ui/base/Typography.astro";
import {
  type CategoryTreeNode,
  buildCategoryTree,
  buildResourceExistenceSet,
  pruneTreeForPopulation,
} from "@ui/utils/nav-utils";
import { getCollection, type CollectionEntry } from "astro:content";
import PageHeaderLayout from "@ui/layouts/PageHeaderLayout.astro";
import { makeLabelPartsForPopulationResources } from "@content/utils";
import LayoutSurface from "@ui/base/LayoutSurface.astro";
import Container from "@ui/base/Container.astro";
import Stack from "@ui/base/Stack.astro";
import CategoryTree from "@ui/composite/content-linked/category/CategoryTree.astro";

interface Props {
  populationEntry: CollectionEntry<"populations">;
  categoryTrees: CategoryTreeNode[];
}

export async function getStaticPaths() {
  const [populationEntries, categories] = await Promise.all([
    getCollection("populations"),
    getCollection("categories"),
  ]);

  // Find root categories (those not appearing as children of any other)
  const childIds = new Set(
    categories.flatMap((c) => c.data.subcategories.map((sub) => sub.id)),
  );
  const rootCategories = categories.filter((c) => !childIds.has(c.id));

  // Authoritative ordering determined by project lead
  const authoritativeRootCategorySlugs = [
    "topics",
    "types-of-loss",
    "supporting-the-bereaved",
    "finding-peer-support-and-support-groups",
  ] as const;
  const authoritativeRootCategories = authoritativeRootCategorySlugs
    .map((slug) => rootCategories.find((c) => c.data.slug === slug))
    .filter((c): c is CollectionEntry<"categories"> => c !== undefined);

  // Build full category trees and resource existence set once
  const fullTrees = authoritativeRootCategories.map((rootCat) =>
    buildCategoryTree(rootCat, categories),
  );
  const existenceSet = await buildResourceExistenceSet();

  return populationEntries.map((populationEntry) => {
    // Prune all trees for this population
    const prunedTrees = fullTrees
      .map((tree) =>
        pruneTreeForPopulation(
          tree,
          populationEntry.id,
          populationEntry.data.slug,
          existenceSet,
        ),
      )
      .filter((node): node is CategoryTreeNode => node !== null);

    return {
      params: {
        population: populationEntry.data.slug,
      },
      props: {
        populationEntry,
        categoryTrees: prunedTrees,
      },
    };
  });
}

const { populationEntry, categoryTrees } = Astro.props;

const labelParts = await makeLabelPartsForPopulationResources(
  populationEntry.id,
);
---

<SitePageLayout>
  <PageHeaderLayout
    surfaceVariant="tertiary"
    surfaceVariantKey={3}
    image={populationEntry.data.image}
  >
    <div class="md:h-full md:flex md:flex-col">
      <div class="md:h-full md:flex md:items-center">
        <div class="px-8 py-12 md:flex md:items-center md:justify-end md:grow">
          <div class="basis-100">
            <Typography as="span" variant="body-2" class="block" italic>
              {`${labelParts[0]} `}
            </Typography>
            <Typography as="span" variant="title-2">
              {labelParts[1]}
            </Typography>
          </div>
        </div>
      </div>
    </div>
  </PageHeaderLayout>
  <LayoutSurface as="section" paddingX={2} paddingY={5}>
    <Container>
      <Stack spacing={4}>
        <Typography variant="body-2">
          {
            `We have a range of ${labelParts.join(" ")} across the following categories:`
          }
        </Typography>
        <CategoryTree trees={categoryTrees} />
      </Stack>
    </Container>
  </LayoutSurface>
</SitePageLayout>
